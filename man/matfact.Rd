% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix-factorisation.R
\name{funksvd}
\alias{funksvd}
\title{Matrix factorisation (Funk SVD)}
\usage{
funksvd(Y, k_dim, test = NULL, epochs = 500, lr = 0.001,
  lambda = 0.02, tol = 1e-06, pbar = FALSE)
}
\arguments{
\item{Y}{Matrix with missing values. Missing values should be \code{NA}}

\item{k_dim}{Number of latent variables}

\item{test}{The selected test set of observations. See \code{select_test}}

\item{epochs}{Maximum iterations}

\item{lr}{Learning rate}

\item{lambda}{Regularisation parameter}

\item{tol}{Iteration tolerance}

\item{pbar}{Progress bar toggle. Turning progress on does slow computation slightly.}
}
\description{
Applies matrix factorisation by gradient descent to a given matrix with missing values
}
\details{
Implements matrix factorisation by gradient descent. Matrix \code{Y} should have \code{NA}'s as missing values. The matrix will be factorised
into two matrices U and V, the user and feature matrix. The U matrix essentially contains the ;weight each user gives to a certain feature. The
function will output the accuracy of the selected test sample by using \code{test}. The prediction matrix is return as \code{pred} but can be
calculated by UV^T.

See \code{select_test} for more information.
}
\examples{
\dontrun{
m <- matrix(sample(c(NA, 1:5), 60, replace = TRUE, prob = c(0.2, rep(0.8/5, 5))), nrow = 10)
id <- select_test(m, 0.2)
mf <- funksvd(m, 2, test = id$test, pbar = TRUE)
mf$u \%*\% t(mf$v)
}
}
